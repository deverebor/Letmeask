AULA 01:

Conteúdos de suporte:
Flowchart sobre o formato SPA: https://whimsical.com/nlw-together-Xr7p33QfRwZsR1t9f2WGta
Figma do Letmeask: https://www.figma.com/file/u0BQK8rCf2KgzcukdRRCWh/Letmeask/duplicate
Configuração do ambiente: https://www.notion.so/NLW-Together-Conte-dos-complementares-ae22125e899549efb2d4e360b5ee5ca3

SPA > Modelo de página atual

Utilizar o import { função } from './pasta/arquivo' é melhor do que exportar como default, porque se houver a alteração da variável ele não ira receber mais a função, no caso ajuda na semântica do código. O nome disso se chama "named export" você precisa dar um nome ao que vai ser exportado para respectivamente importar. 

Todas as propriedades que são enviadas para o componente são enviadas como argumentos da função.

Sempre que se for incluir um código JavaScript dentro do JSX que é o HTML inserido no JavaScript sempre vai ser com {}. 

Sempre criamos um estado como constante, mesmo que o valor seja alterado.

No ReactJS existe um conceito chamado de imutabilidade, a partir do momento que uma variável foi criada dentro de um estado de um componente ela não sofre alterações, sempre se cria uma nova informação, baseada na anterior.

-------------------------------------------------------------------------------
AULA 02:

Todo arquivo de um componente deve se começar com a letra maiúscula EX: Home.tsx 
Não se pode utilizar com letra minúscula porque se não o navegador confunde com uma tag html tradicional.

imagem.svg o svg são vetores que nunca perdem resolução.

Quando se referencia uma imagem no ReactJS não coloca simplesmente o src da imagem ou qualquer arquivo sempre se utiliza importação, ou seja um *import arquivo from 'local'* para ser exportado na parte necessária da aplicação.

&amp; => símbolo de & 

O react tem suporte para implementar o SASS entretanto utilizando o pacote do facebook(create-react-app), o suporte é exclusivo (até o momento) do 5.0 para adicionar o suporte se usa:
yarn add node-sass@^5.0.0

Para o design da página ser mais bonita visualmente é necessário utilizar múltiplos de 8 na disponibilização dos container, paddings, width, height e afins. EX:
8px, 16px, 24px, 32px e etc

No ReactJS a declaração de uma classe em uma tag se utiliza o className="" e não class="" como é utilizado no html padrão.

Quando avistamos algo que se repete muito em uma aplicação como por exemplo a estilização de um botão é o primeiro indicio da necessidade de criação de um componente, para ter o encapsulamento disso e se reaproveitar em vários lugares.

**MELHORAR A DOCUMENTAÇÃO DO CÓDIGO AO FINAL DA NLW**

A parte de navegação que ocorre dentro de uma página com ReactJS é feito com o react-router-dom, ele permite que a transição ocorra entre as páginas internas do projeto assim trazendo a tona o SPA (Single Page Application).
O pacote react-router não possui suporte para typescript, então a comunidade utiliza um pacote de terceiros para criar esse suporte utilizando o yarn add @types/react-router-dom

[App.tsx => Linha 14] O *exact* é utilizado dentro da <Route /> para dizer que precisa ser exatamente aquele caminho para funcionar o redirecionamento para a página. O *exact* pode ser tanto *true* quanto *false*, o valor padrão desse parâmetro é true a sua estrutura é a seguinte: exact={true} ou exact={false}.

[Home.tsx => Linha 18] Toda função que começa com "use" é chamada de hook no ReactJS e todo hook tem que estar dentro do componente porque ele faz uso de informações que fazem parte do contexto do componente. Na linha 18 é utilizado o useHistory() para saber se o usuário já está autenticado na aplicação e caso haja um F5 na página não o redirecione novamente para o login, assim evitando problemas de relogagem desnecessárias na aplicação.

Contextos no reactjs nada mais é do que uma forma de compartilhar informações entre dois ou mais componentes e essa informação pode ser qualquer coisa como um texto, array e etc. Por exemplo o arquivo AuthContext.tsx, onde se armazena o contexto de autenticação do usuário na aplicação.

[AuthContext.tsx => Linha 25] Todo estado se cria dessa forma: 
const [value, setValue] = objeto()

[AuthContext.tsx => Linha 73] {{}} => representa um código de javascript com um objeto dentro, a primeira {} é o código e a {{}} é o objeto.

Toda função async (assíncrona) devolve uma promessa no JavaScript.

{user?.name} a interrogação é utilizada porque o usuário pode ser undefined quando não está logado.

[AuthContext.tsx => Linha 27] useEffect() => hook para disparo de efeitos colaterais ou funcionalidades, vai ser utilizado para disparar uma função sempre que algo acontecer como: mudança de informação, quando um componente for mostrado em tela e etc. Ele recebe 2 parâmetros:
1- *Função* que será executada(arrow function);
2- *Quando* será executada (sempre será um array);
Ex de sua criação: useEffect(() => {}, [])
Dentro desse vetor será escolhido qual informação será monitorada. Se for necessário disparar essa função uma única vez deixa-se o array vazio se não passa-se a propriedade que será monitorada..

[AuthContext.tsx => Linha 45] Toda vez que se declara um event listener é recomendado que salve ele em uma variável para que caso seja necessário não o "ouça" mais. Também recomenda-se o retorno removendo o cadastro de todos os event listener já armazenados, SOMENTE SE estiver cadastrado em algum event listener. 
Uma boa pratica é: 
*Toda vez que se declarar um event listener deve ser feito a remoção do cadastro sempre no final do método.* 

[AuthContext.tsx => Linha 02] Sempre que for enviado um componente do ReactJS como children o tipo necessita vim de dentro da propriedade *ReactNode* do ReactJS EX: 
import { createContext, *ReactNode* } from "react"
Isso permite o compartilhamento dessa children pelo projeto.

-------------------------------------------------------------------------------
AULA 03:

Quando temos um await dentro de uma função o código abaixo dele só ira ser executado caso ele receba oque pede. Caso receba um erro, não continuara executando o código.

Toda função que é passada nativamente do HTML como o onSubmit={} do formulário ela recebe como parametro o próprio evento para conseguir manipular de alguma forma. No caso do onSubmit ele é um evento de formulario e eu consigo obter informações dele por conta disso.