AULA 01:

Conteúdos de suporte:
Flowchart sobre o formato SPA: https://whimsical.com/nlw-together-Xr7p33QfRwZsR1t9f2WGta
Figma do Letmeask: https://www.figma.com/file/u0BQK8rCf2KgzcukdRRCWh/Letmeask/duplicate
Configuração do ambiente: https://www.notion.so/NLW-Together-Conte-dos-complementares-ae22125e899549efb2d4e360b5ee5ca3

SPA > Modelo de página atual

Utilizar o import { função } from './pasta/arquivo' é melhor do que exportar como default, porque se houver a alteração da variável ele não ira receber mais a função, no caso ajuda na semântica do código. O nome disso se chama "named export" você precisa dar um nome ao que vai ser exportado para respectivamente importar. 

Todas as propriedades que são enviadas para o componente são enviadas como argumentos da função.

Sempre que se for incluir um código JavaScript dentro do JSX que é o HTML inserido no JavaScript sempre vai ser com {}. 

Sempre criamos um estado como constante, mesmo que o valor seja alterado.

No ReactJS existe um conceito chamado de imutabilidade, a partir do momento que uma variável foi criada dentro de um estado de um componente ela não sofre alterações, sempre se cria uma nova informação, baseada na anterior.

-------------------------------------------------------------------------------
AULA 02:

Todo arquivo de um componente deve se começar com a letra maiúscula EX: Home.tsx 
Não se pode utilizar com letra minúscula porque se não o navegador confunde com uma tag html tradicional.

imagem.svg o svg são vetores que nunca perdem resolução.

Quando se referencia uma imagem no ReactJS não coloca simplesmente o src da imagem ou qualquer arquivo sempre se utiliza importação, ou seja um *import arquivo from 'local'* para ser exportado na parte necessária da aplicação.

&amp; => símbolo de & 

O react tem suporte para implementar o SASS entretanto utilizando o pacote do facebook(create-react-app), o suporte é exclusivo (até o momento) do 5.0 para adicionar o suporte se usa:
yarn add node-sass@^5.0.0

Para o design da página ser mais bonita visualmente é necessário utilizar múltiplos de 8 na disponibilização dos container, paddings, width, height e afins. EX:
8px, 16px, 24px, 32px e etc

No ReactJS a declaração de uma classe em uma tag se utiliza o className="" e não class="" como é utilizado no html padrão.

Quando avistamos algo que se repete muito em uma aplicação como por exemplo a estilização de um botão é o primeiro indicio da necessidade de criação de um componente, para ter o encapsulamento disso e se reaproveitar em vários lugares.

**MELHORAR A DOCUMENTAÇÃO DO CÓDIGO AO FINAL DA NLW**

A parte de navegação que ocorre dentro de uma página com ReactJS é feito com o react-router-dom, ele permite que a transição ocorra entre as páginas internas do projeto assim trazendo a tona o SPA (Single Page Application).
O pacote react-router não possui suporte para typescript, então a comunidade utiliza um pacote de terceiros para criar esse suporte utilizando o yarn add @types/react-router-dom

[App.tsx => Linha 14] O *exact* é utilizado dentro da <Route /> para dizer que precisa ser exatamente aquele caminho para funcionar o redirecionamento para a página. O *exact* pode ser tanto *true* quanto *false*, o valor padrão desse parâmetro é true a sua estrutura é a seguinte: exact={true} ou exact={false}.

[Home.tsx => Linha 18] Toda função que começa com "use" é chamada de hook no ReactJS e todo hook tem que estar dentro do componente porque ele faz uso de informações que fazem parte do contexto do componente. Na linha 18 é utilizado o useHistory() para saber se o usuário já está autenticado na aplicação e caso haja um F5 na página não o redirecione novamente para o login, assim evitando problemas de relogagem desnecessárias na aplicação.

Contextos no reactjs nada mais é do que uma forma de compartilhar informações entre dois ou mais componentes e essa informação pode ser qualquer coisa como um texto, array e etc. Por exemplo o arquivo AuthContext.tsx, onde se armazena o contexto de autenticação do usuário na aplicação.

[AuthContext.tsx => Linha 25] Todo estado se cria dessa forma: 
const [value, setValue] = objeto()

[AuthContext.tsx => Linha 73] {{}} => representa um código de javascript com um objeto dentro, a primeira {} é o código e a {{}} é o objeto.

Toda função async (assíncrona) devolve uma promessa no JavaScript.

{user?.name} a interrogação é utilizada porque o usuário pode ser undefined quando não está logado.

[AuthContext.tsx => Linha 27] useEffect() => hook para disparo de efeitos colaterais ou funcionalidades, vai ser utilizado para disparar uma função sempre que algo acontecer como: mudança de informação, quando um componente for mostrado em tela e etc. Ele recebe 2 parâmetros:
1- *Função* que será executada(arrow function);
2- *Quando* será executada (sempre será um array);
Ex de sua criação: useEffect(() => {}, [])
Dentro desse vetor será escolhido qual informação será monitorada. Se for necessário disparar essa função uma única vez deixa-se o array vazio se não passa-se a propriedade que será monitorada.

[AuthContext.tsx => Linha 45] Toda vez que se declara um event listener é recomendado que salve ele em uma variável para que caso seja necessário não o "ouça" mais. Também recomenda-se o retorno removendo o cadastro de todos os event listener já armazenados, SOMENTE SE estiver cadastrado em algum event listener. 
Uma boa pratica é: 
*Toda vez que se declarar um event listener deve ser feito a remoção do cadastro sempre no final do método.* 

[AuthContext.tsx => Linha 02] Sempre que for enviado um componente do ReactJS como children o tipo necessita vim de dentro da propriedade *ReactNode* do ReactJS EX: 
import { createContext, *ReactNode* } from "react"
Isso permite o compartilhamento dessa children pelo projeto.

-------------------------------------------------------------------------------
AULA 03:

Quando temos um await dentro de uma função o código abaixo dele só ira ser executado caso ele receba o que pede. Caso receba um erro, não continuara executando o código.

Toda função que é passada nativamente do HTML como o onSubmit={} do formulário ela recebe como parâmetro o próprio evento para conseguir manipular de alguma forma. No caso do onSubmit ele é um evento de formulário e é possível obter informações dele por conta disso.
Sem que se separa a função é necessário tipar ela.

[Home.tsx => Linha 41] A reference no firebase nada mais é que a referencia para um registro de dado dentro do banco de dados

[Home.tsx => Linha 34] Para passar um parâmetro em uma rota se utiliza os " :nome_do_parâmetro"

[App.tsx => Linha 15] O <Switch> </Switch> é um componente do react-router-dom que tem como funcionalidade dizer se uma rota(<Route />) foi acessada e ele irá parar de procurar outras caso a primeira rota satisfaça aquele mesmo endereço

[NewRoom.tsx => Linha 36] O .key é o id que foi inserido no banco de dados, nesse caso essa .key levará o usuário para a sala criada.

[Home.tsx => Linha 38] Em qualquer formulário do react é necessário se utilizar o event.preventDefault() dentro da sua função. Chamar preventDefault() durante qualquer fase do fluxo de eventos cancela o evento, o que significa que qualquer ação padrão normalmente feita pela aplicação como um resultado do evento não ocorrerá.

[Home.tsx => Linha 41] O .get() pega todos os dados da sala.

[firebase => realtime database(alteração no site)] A autorização é o processo de dar permissões para oque o usuário pode fazer na sua aplicação.
Lógica utilizada na configuração das autorizações do banco de dados do firebase:

{
  "rules": {
    "rooms": {
      ".read": false,
      ".write": "auth != null",
      "$roomId": {
        ".read": true,
        ".write": "auth != null && (!data.exists() || data.child('authorId').val() == auth.id)",
        "questions": {
          ".read": true,
          ".write": "auth != null && (!data.exists() || data.parent().child('authorId').val() == auth.id)",
          "likes": {
            ".read": true,
            ".write": "auth != null && (!data.exists() || data.child('authorId').val() == auth.id)",  
          }
        }
      }
    }
  }
}

1- rooms => leitura do usuário será falsa e ele só poderá escrever o conteúdo se for autenticado na sala.

2- $roomID => mesmo que o usuário não esteja autenticado ele poderá ler as perguntas, a criação do conteúdo é aberto mas para alterar o valor o usuário precisa ser o mesmo que criou.

3- questions => mesmo que o usuário não esteja autenticado ele poderá ler das perguntas, a criação do conteúdo é aberto mas para alterar o valor o usuário precisa ser o mesmo que criou.

4- likes => mesmo que o usuário não esteja autenticado ele poderá dar ler, a criação do conteúdo é aberto mas para alterado usuário precisa ser o mesmo que criou.

Ordem de posições do padding = cima, direita, baixo, esquerda

Quando se usa o useParams() da biblioteca do react-router-dom ele não sabe quais os parâmetros serão usados na rota. Para se resolver cria-se um type para falar quais são os parâmetros que serão puxados.

quando se utiliza um type em conjunto com uma função é chamado de generics ex:
const params = useParams*<RoomParams>*()
O RoomParams é passado como um parâmetro passado para a tipagem.

[Room.tsx => Linha 84 - 99] Configuração das mensagens de erro utilizando o react-hot-toast.

[Room.tsx => Linha 96] O setNewQuestion('') serve para retornar o valor da caixa de texto para vazio após o envio da pergunta.

[Room.tsx => Linha 122] O "? :" são operadores ternários do JavaScript utilizados para uma condição(if else) implícita. 

[Room.tsx => Linha 26] Para buscar os dados das perguntas no firebase segundo a sua documentação é da seguinte maneira.

O Object.entries() funciona da seguinte maneira um objeto é transformado em uma array com cada posição do array sendo chave e valor. EX:

const obj = {
  "name": "Lucas"
  "idade": 19
}

Object.entries(obj) => [ ["name", "Lucas"], ["idade", 19] ]

Para fazer tipagem de objetos no TypeScript se utiliza *Record<>*

[Room.tsx => Linha 56] Se eu quero informar que eu sei o tipo de alguma informação no TypeScript pode se usar um nome_variável "as" tipo ou pode-se atribuir um novo valor a variável e falar que ela tem um tipo "variável: tipo"

** [Room.tsx => Linha 54]RESOLVER PROBLEMA DO roomRef.on() repetir sempre a função de parsed ter que ouvir apenas inserções, modificações, ou remoções PESQUISAR SOBRE CHILD ADD FIREBASE 

[Room.tsx => Linha 123] *Criar uma nova variável* que só executa quando receber um valor que foi digitado onChange no <form> **

LER SOBRE CMAP TOOLS
IDEIA DE COMO RESOLVER O PROBLEMA:
id="testeEscuta" => no (<form> Linha 123)

async function test(){
        const testState = document.getElementById('testeEscuta')

        
    }

-------------------------------------------------------------------------------
AULA 04: